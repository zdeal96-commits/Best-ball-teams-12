<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Best Ball Bet Sheet</title>

  <style>
    :root{
      --bg0:#07110d;
      --bg1:#0b1f16;
      --text:#eaf5ef;
      --muted:#b7d1c2;
      --line: rgba(255,255,255,.10);

      --accent:#34d399;
      --accent2:#22c55e;
      --warn:#fbbf24;
      --bad:#fb7185;

      --shadow: 0 14px 45px rgba(0,0,0,.45);
      --radius: 16px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      color:var(--text);
      font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 800px at 20% 0%, rgba(52,211,153,.18), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(251,191,36,.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, #06110c);
      padding: 14px 14px 92px;
    }
    .wrap{ max-width: 980px; margin: 0 auto; }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
      margin-bottom: 12px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .topRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:flex-start;
      justify-content:space-between;
    }
    .title{ margin:0; font-size:18px; font-weight:950; letter-spacing:.2px; }
    .sub{ margin-top:6px; color:var(--muted); font-size:12.5px; line-height:1.25; max-width: 740px; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--line);
      color: var(--text);
      font-size:12px; white-space:nowrap;
      height: fit-content;
    }
    .pill .dot{
      width:10px;height:10px;border-radius:50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(52,211,153,.18);
    }

    label{
      display:block;
      color: var(--muted);
      font-size: 12px;
      font-weight: 900;
      letter-spacing:.2px;
      margin: 0 0 6px;
    }
    input, textarea{
      width:100%;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(9, 24, 17, .55);
      color: var(--text);
      outline: none;
      font-size: 16px;
    }
    textarea{ min-height: 46px; resize: vertical; }

    .grid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    @media (min-width: 860px){
      .grid2{ grid-template-columns: 1fr 1fr; }
      .grid3{ grid-template-columns: 1fr 1fr 1fr; }
    }

    .btnRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .btn{
      border:0;
      border-radius: 12px;
      padding: 11px 12px;
      font-size: 15px;
      font-weight: 950;
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, filter .15s ease;
    }
    .btn:active{ transform: scale(.99); }
    .btnPrimary{
      background: linear-gradient(135deg, var(--accent2), var(--accent));
      color:#08110c;
      box-shadow: 0 12px 30px rgba(34,197,94,.22);
    }
    .btnGhost{
      background: rgba(255,255,255,.08);
      color: var(--text);
      border: 1px solid var(--line);
    }
    .btnDanger{
      background: linear-gradient(135deg, #fb7185, #ef4444);
      color:#08110c;
      box-shadow: 0 12px 30px rgba(239,68,68,.18);
    }

    .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.25;
      margin-top: 8px;
    }

    .rowCard{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 12px;
      background: rgba(0,0,0,.14);
      margin-top: 10px;
    }
    .rowCard.flash{
      outline: 2px solid rgba(52,211,153,.45);
      box-shadow: 0 0 0 6px rgba(52,211,153,.12);
      animation: flash 1.2s ease-out;
    }
    @keyframes flash{
      0%{ transform: translateY(2px); filter: brightness(1.06); }
      100%{ transform: translateY(0); filter: brightness(1); }
    }

    .rowHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .rowTitle{
      font-weight: 950;
      font-size: 14px;
      letter-spacing:.2px;
      color: var(--muted);
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size: 12px;
      font-weight: 900;
      white-space:nowrap;
    }

    .teams{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 860px){
      .teams{ grid-template-columns: 1fr 1fr; gap: 12px; }
    }
    .sideLabel{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 6px;
    }
    .sideTools{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .miniBtn{
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 7px 9px;
      border-radius: 12px;
      font-weight: 950;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
    }

    .acWrap{ position: relative; }
    .suggest{
      position:absolute;
      left:0; right:0;
      top: calc(100% + 6px);
      z-index: 50;
      background: rgba(8, 20, 14, .98);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      box-shadow: 0 16px 40px rgba(0,0,0,.55);
      overflow:hidden;
      max-height: 210px;
      overflow-y:auto;
    }
    .suggestItem{
      padding: 10px 12px;
      font-size: 14px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      cursor:pointer;
      user-select:none;
    }
    .suggestItem:last-child{ border-bottom: 0; }
    .suggestItem:hover{ background: rgba(255,255,255,.06); }

    .resultBox{
      margin-top: 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      padding: 12px;
    }
    .resultTop{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
    }
    .winner{
      font-weight: 950;
      font-size: 16px;
      letter-spacing:.2px;
    }
    .winner.good{ color: #5eead4; }
    .winner.bad{ color: #fda4af; }
    .winner.push{ color: var(--warn); }

    .bigMoney{
      font-weight: 950;
      font-size: 18px;
      letter-spacing:.2px;
    }
    .muted{ color: var(--muted); font-size: 12px; line-height:1.25; margin-top: 6px; }

    .errorLine{
      margin-top: 8px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(251,113,133,.35);
      background: rgba(251,113,133,.10);
      color: #ffd6de;
      font-size: 13px;
      font-weight: 900;
      line-height: 1.25;
    }

    .rowActions{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-top: 10px;
    }
    @media (min-width: 560px){
      .rowActions{ grid-template-columns: 1fr 1fr 1fr; }
    }

    .summaryBox{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      padding: 12px;
      margin-top: 12px;
    }
    .mono{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-wrap;
      font-size: 13px;
      line-height: 1.35;
      color: #d6f2e6;
    }

    .hubbar{
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 9999;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, rgba(5,17,11,.70), rgba(5,17,11,.92));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
    }
    .hubbarRow{
      max-width: 980px;
      margin: 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .hubbarTitle{
      color: #eaf5ef;
      font-weight: 950;
      font-size: 13px;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 55vw;
    }
    .hubBtns{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .hubBtn{
      border:0;
      border-radius: 12px;
      padding: 9px 10px;
      font-size: 12.5px;
      font-weight: 950;
      cursor:pointer;
      user-select:none;
    }
    .hubBtnGhost{
      background: rgba(255,255,255,.08);
      color:#eaf5ef;
      border: 1px solid rgba(255,255,255,.10);
    }
    .hubBtnDanger{
      background: linear-gradient(135deg, #fb7185, #ef4444);
      color:#08110c;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="card">
      <div class="topRow">
        <div>
          <h1 class="title">Best Ball Bet Sheet</h1>
          <div class="sub">
            Load a Squabbit CSV once. Then fill Team A vs Team B.
            Winner, stroke difference, and payouts are automatic. No side scrolling.
          </div>
        </div>
        <div class="pill"><span class="dot"></span><span><b>Local save</b> (this device)</span></div>
      </div>
    </div>

    <div class="card">
      <div class="grid grid3">
        <div>
          <label>1) Load Squabbit CSV (required)</label>
          <input id="csvInput" type="file" accept=".csv,text/csv" />
          <div class="hint" id="csvStatus">No CSV loaded yet.</div>
        </div>

        <div>
          <label>$ per stroke (global)</label>
          <input id="dollarsPerShot" type="number" min="0" step="1" value="5" />
          <div class="hint">Example: $5 per stroke.</div>
        </div>

        <div>
          <label>Max strokes (cap, global)</label>
          <input id="maxShots" type="number" min="1" step="1" value="5" />
          <div class="hint">Example: cap at 5 strokes. (Cannot be 0.)</div>
        </div>
      </div>

      <div class="grid grid2" style="margin-top:10px;">
        <div>
          <label>Quick find (filters rows by name)</label>
          <input id="filterInput" placeholder="Type a name... (Zack, Blair, etc)" />
          <div class="hint">Tip: autocomplete list builds from the CSV player names.</div>
        </div>

        <div class="btnRow" style="justify-content:flex-end; align-items:end;">
          <button class="btn btnPrimary" id="addRowBtn" type="button">Add Row</button>
          <button class="btn btnGhost" id="clearSheetBtn" type="button">Clear Sheet</button>
        </div>
      </div>

      <div class="hint" style="margin-top:10px;">
        Entry tips:
        <br>• Teams are comma-separated names (autocomplete helps).
        <br>• Shortcut: type <b>""</b> in Team A or Team B to reuse the previous row on that side.
        <br>• You cannot use the same player on both teams in the same row.
      </div>
    </div>

    <div class="card" id="rowsWrap">
      <div class="hint" id="rowsCount">No rows yet. Tap “Add Row”.</div>
      <div id="rowsList"></div>

      <div class="summaryBox" id="summaryBox" style="display:none;">
        <div class="rowHeader" style="margin-bottom:6px;">
          <div class="rowTitle">Payout Summary</div>
          <span class="chip" id="summaryChip">—</span>
        </div>

        <div class="btnRow" style="margin-bottom:10px;">
          <button class="btn btnGhost" id="copySummaryBtn" type="button">Copy Payout Summary</button>
          <button class="btn btnGhost" id="downloadSheetBtn" type="button">Download Sheet CSV</button>
        </div>

        <div class="mono" id="summaryText"></div>
      </div>
    </div>

  </div>

  <div class="hubbar">
    <div class="hubbarRow">
      <div class="hubbarTitle" id="hubToolTitle">Best Ball Bet Sheet</div>
      <div class="hubBtns">
        <button class="hubBtn hubBtnGhost" type="button" id="hubBackBtn">← Back to Hub</button>
        <button class="hubBtn hubBtnGhost" type="button" id="hubResetThisBtn">Reset This Tool</button>
        <button class="hubBtn hubBtnDanger" type="button" id="hubResetAllBtn">Reset Everything</button>
      </div>
    </div>
  </div>

<script>
(() => {
  window.TOOL_NAME = "Best Ball Bet Sheet";
  window.TOOL_STORAGE_KEYS = ["bestball_bet_sheet_v3"];
  window.HUB_INDEX = "index.html";

  const LS_KEY = "bestball_bet_sheet_v3";
  const $ = (id) => document.getElementById(id);

  // --------- CSV parsing helpers ----------
  const splitCSVLine = (line) => {
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i = 0; i < line.length; i++) {
      const c = line[i];
      if (c === '"') {
        if (inQ && line[i + 1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (c === ',' && !inQ) {
        out.push(cur);
        cur = "";
      } else {
        cur += c;
      }
    }
    out.push(cur);
    return out.map(s => (s || "").trim());
  };
  const parseCSVRows = (text) => text.split(/\r?\n/).map(splitCSVLine);

  const toInt = (v) => {
    const s = (v ?? "").toString().trim();
    if (!/^\d+$/.test(s)) return null;
    const n = parseInt(s, 10);
    return Number.isFinite(n) ? n : null;
  };

  const buildHoleIndex = (row) => {
    const idx = {};
    row.forEach((c, i) => {
      const s = (c || "").toLowerCase().trim();
      for (let h = 1; h <= 18; h++) {
        if (s === `hole ${h}` || s === `${h}` || s === `hole${h}`) idx[h] = i;
      }
    });
    return Object.keys(idx).length ? idx : null;
  };

  const normalizeName = (n) => (n || "").trim().replace(/\s+/g, " ");
  const normKey = (n) => normalizeName(n).toLowerCase();

  const parsePlayersFromSquabbitCSV = (txt) => {
    const rows = parseCSVRows(txt);
    let holeIdx = null;
    const map = new Map();

    for (const row of rows) {
      const joined = row.map(c => (c || "").toLowerCase()).join(" ");
      if (
        joined.includes("individual gross skins") ||
        joined.includes("strokeplay") ||
        joined.includes("best ball") ||
        joined.includes("par") ||
        joined.startsWith("s.i.")
      ) continue;

      if (!holeIdx && row.some(c => /hole\s*1/i.test(c || ""))) {
        holeIdx = buildHoleIndex(row);
        continue;
      }
      if (!holeIdx) continue;

      const nameRaw = normalizeName(row[0]);
      if (!nameRaw) continue;

      const strokes = [];
      for (let h = 1; h <= 18; h++) {
        const col = holeIdx[h];
        const val = (col != null) ? toInt(row[col]) : null;
        if (val == null) { strokes.length = 0; break; }
        strokes.push(val);
      }
      if (strokes.length !== 18) continue;

      map.set(nameRaw.toLowerCase(), { name: nameRaw, strokes });
    }

    return [...map.values()].sort((a,b)=>a.name.localeCompare(b.name));
  };

  // --------- best ball ----------
  function bestBallScore(playersByLowerName, teamNames){
    const members = teamNames
      .map(n => playersByLowerName.get(normKey(n)))
      .filter(Boolean);
    if(!members.length) return null;

    let total = 0;
    for(let i=0;i<18;i++){
      let m = Infinity;
      for(const p of members) m = Math.min(m, p.strokes[i]);
      if(!Number.isFinite(m)) return null;
      total += m;
    }
    return total;
  }

  // --------- state ----------
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      return raw ? JSON.parse(raw) : null;
    } catch {
      return null;
    }
  }
  function saveState(st){
    localStorage.setItem(LS_KEY, JSON.stringify(st));
  }
  function newState(){
    return {
      dollarsPerShot: 5,
      maxShots: 5,
      csvLoadedAt: null,
      players: [],
      rows: [],
      lastAddedRowIndex: null
    };
  }

  let state = loadState() || newState();

  function clampSettings(){
    let d = Number(state.dollarsPerShot);
    if(!Number.isFinite(d) || d < 0) d = 5;

    let cap = Number(state.maxShots);
    if(!Number.isFinite(cap) || cap < 1) cap = 5; // IMPORTANT: cap cannot be 0

    state.dollarsPerShot = Math.round(d);
    state.maxShots = Math.round(cap);
  }

  function setCSVStatus(msg){ $("csvStatus").textContent = msg; }

  function playersMap(){
    const m = new Map();
    state.players.forEach(p => m.set(p.name.toLowerCase(), p));
    return m;
  }

  function parseTeamInput(str){
    const s = (str || "").trim();
    if(!s) return [];
    return s.split(",").map(x => normalizeName(x)).filter(Boolean);
  }

  function teamKeys(teamArr){
    return teamArr.map(normKey).filter(Boolean);
  }

  function findDuplicates(arrKeys){
    const seen = new Set();
    const dups = new Set();
    for(const k of arrKeys){
      if(seen.has(k)) dups.add(k);
      seen.add(k);
    }
    return [...dups];
  }

  // payout rule: each loser owes (shotsUsed * $/stroke)
  function computePayout(margin, dollarsPerShot, maxShots, winnersCount, losersCount){
    const shots = Math.min(margin, Math.max(1, maxShots)); // cap min 1, already clamped
    const perLoser = shots * dollarsPerShot;
    const total = perLoser * losersCount;
    const perWinner = winnersCount > 0 ? (total / winnersCount) : 0;
    return { shots, perLoser, total, perWinner };
  }

  function money(n){
    return (Math.round((n + Number.EPSILON) * 100) / 100).toFixed(2);
  }

  // --------- autocomplete ----------
  function makeAutocomplete(inputEl, getNames, getBlockedKeys, onPick){
    let box = null;

    function close(){ if(box) box.remove(); box = null; }
    function open(list){
      close();
      if(!list.length) return;
      box = document.createElement("div");
      box.className = "suggest";
      list.forEach(name => {
        const it = document.createElement("div");
        it.className = "suggestItem";
        it.textContent = name;
        it.onclick = () => { onPick(name); close(); };
        box.appendChild(it);
      });
      inputEl.parentElement.appendChild(box);
    }

    function currentToken(str){
      const s = str || "";
      const parts = s.split(",");
      return (parts[parts.length - 1] || "").trim();
    }

    function refresh(){
      const token = currentToken(inputEl.value).toLowerCase();
      const names = getNames();
      const blocked = new Set(getBlockedKeys());
      const list = names
        .filter(n => !token || n.toLowerCase().includes(token))
        .filter(n => !blocked.has(n.toLowerCase()))
        .slice(0, 10);
      open(list);
    }

    inputEl.addEventListener("input", refresh);
    inputEl.addEventListener("focus", refresh);
    inputEl.addEventListener("blur", () => setTimeout(close, 140));
    inputEl.addEventListener("keydown", (e) => { if(e.key === "Escape") close(); });
  }

  function appendNameWithComma(existing, picked){
    const s = existing || "";
    const parts = s.split(",");
    parts[parts.length - 1] = " " + picked;
    const cleaned = parts.map(p => p.trim()).filter((p, i) => i === parts.length - 1 ? true : p.length);
    let out = cleaned.join(", ");
    out = out.replace(/\s+,/g, ",");
    if (!out.endsWith(", ")) out += ", ";
    return out.replace(/^, /, "");
  }

  function getNameList(){
    const set = new Set();
    state.players.forEach(p => set.add(p.name));
    state.rows.forEach(r => {
      parseTeamInput(r.a).forEach(n => set.add(n));
      parseTeamInput(r.b).forEach(n => set.add(n));
    });
    return [...set].sort((a,b)=>a.localeCompare(b));
  }

  function rowIncludesName(row, name){
    const n = name.toLowerCase();
    return (row.a||"").toLowerCase().includes(n) || (row.b||"").toLowerCase().includes(n);
  }

  // --------- row result ----------
  function computeRowResult(row, idx){
    clampSettings();

    // "" shortcut (reuse previous on that side)
    const prev = state.rows[idx - 1];
    const aRaw = (row.a || "").trim();
    const bRaw = (row.b || "").trim();
    const aStr = (aRaw === '""' || aRaw === "“”" || aRaw === "''") && prev ? prev.a : aRaw;
    const bStr = (bRaw === '""' || bRaw === "“”" || bRaw === "''") && prev ? prev.b : bRaw;

    const aTeam = parseTeamInput(aStr);
    const bTeam = parseTeamInput(bStr);

    const aKeys = teamKeys(aTeam);
    const bKeys = teamKeys(bTeam);

    const dupA = findDuplicates(aKeys);
    const dupB = findDuplicates(bKeys);

    const overlap = aKeys.filter(k => bKeys.includes(k));
    if (dupA.length || dupB.length || overlap.length){
      const badNames = new Set();
      dupA.forEach(k => badNames.add(k));
      dupB.forEach(k => badNames.add(k));
      overlap.forEach(k => badNames.add(k));
      return {
        status:"invalid",
        aTeam, bTeam,
        message:
          overlap.length
            ? `Same player on both teams: ${overlap.map(k => (aTeam.find(n=>normKey(n)===k) || bTeam.find(n=>normKey(n)===k) || k)).join(", ")}`
            : `Duplicate name inside a team. Fix Team A/Team B so each player only appears once.`,
      };
    }

    if(!state.players.length){
      return { status:"need_csv", aTeam, bTeam };
    }

    const pMap = playersMap();
    const aScore = aTeam.length ? bestBallScore(pMap, aTeam) : null;
    const bScore = bTeam.length ? bestBallScore(pMap, bTeam) : null;

    if(aScore == null || bScore == null){
      return { status:"need_names", aTeam, bTeam, aScore, bScore };
    }

    if(aScore === bScore){
      return { status:"push", aTeam, bTeam, aScore, bScore };
    }

    const aWins = aScore < bScore;
    const margin = Math.abs(aScore - bScore);

    const winners = aWins ? aTeam : bTeam;
    const losers  = aWins ? bTeam : aTeam;

    const payout = computePayout(
      margin,
      Number(state.dollarsPerShot),
      Number(state.maxShots),
      winners.length,
      losers.length
    );

    return {
      status:"ok",
      aTeam, bTeam,
      aScore, bScore,
      aWins,
      margin,
      winners,
      losers,
      payout
    };
  }

  function buildSettlement(){
    const credits = new Map();
    const debits = new Map();

    state.rows.forEach((row, idx) => {
      const r = computeRowResult(row, idx);
      if(r.status !== "ok") return;

      r.losers.forEach(n => debits.set(n, (debits.get(n)||0) + r.payout.perLoser));
      r.winners.forEach(n => credits.set(n, (credits.get(n)||0) + r.payout.perWinner));
    });

    const debtors = [...debits.entries()].map(([name,amt])=>({name,amt})).filter(x=>x.amt>0.00001).sort((a,b)=>b.amt-a.amt);
    const creditors = [...credits.entries()].map(([name,amt])=>({name,amt})).filter(x=>x.amt>0.00001).sort((a,b)=>b.amt-a.amt);

    let i=0,j=0;
    const lines=[];
    while(i<debtors.length && j<creditors.length){
      const pay = Math.min(debtors[i].amt, creditors[j].amt);
      if(pay>0.00001){
        lines.push(`${debtors[i].name} pays ${creditors[j].name}: $${money(pay)}`);
        debtors[i].amt -= pay;
        creditors[j].amt -= pay;
      }
      if(debtors[i].amt<=0.00001) i++;
      if(creditors[j].amt<=0.00001) j++;
    }
    return lines;
  }

  function updateSummary(){
    if(!state.rows.length){
      $("summaryBox").style.display = "none";
      return;
    }
    $("summaryBox").style.display = "block";

    const computed = state.rows.map((r,i)=>computeRowResult(r,i));
    const okRows = computed.filter(r => r.status === "ok" || r.status === "push");
    $("summaryChip").textContent = `${okRows.length}/${state.rows.length} row(s) have results`;

    const lines=[];
    lines.push("Best Ball Bet Sheet Summary");
    lines.push(`$/stroke: ${state.dollarsPerShot} • cap: ${state.maxShots}`);
    lines.push("");

    state.rows.forEach((row, idx) => {
      const r = computeRowResult(row, idx);
      if(r.status === "need_csv"){
        lines.push(`Row ${idx+1}: Need CSV`);
        return;
      }
      if(r.status === "need_names"){
        lines.push(`Row ${idx+1}: Need names / match CSV`);
        return;
      }
      if(r.status === "invalid"){
        lines.push(`Row ${idx+1}: INVALID — ${r.message}`);
        return;
      }
      if(r.status === "push"){
        lines.push(`Row ${idx+1}: Push (${r.aScore} - ${r.bScore})`);
        return;
      }
      lines.push(
        `Row ${idx+1}: ${r.aWins ? "Team A wins" : "Team B wins"} by ${r.margin} | ` +
        `shots ${r.payout.shots} | each loser owes $${money(r.payout.perLoser)}`
      );
    });

    const settlement = buildSettlement();
    lines.push("");
    lines.push("Settlement:");
    lines.push(settlement.length ? settlement.join("\n") : "All square.");

    $("summaryText").textContent = lines.join("\n");
  }

  // --------- render rows ----------
  function renderRows(){
    clampSettings();

    const filter = ($("filterInput").value || "").trim().toLowerCase();
    const rowsList = $("rowsList");
    rowsList.innerHTML = "";

    const visible = state.rows
      .map((row, idx) => ({ row, idx }))
      .filter(x => !filter || rowIncludesName(x.row, filter));

    $("rowsCount").textContent =
      state.rows.length
        ? `Showing ${visible.length} row(s) • $/stroke ${state.dollarsPerShot} • cap ${state.maxShots}`
        : "No rows yet. Tap “Add Row”.";

    visible.forEach(({row, idx}) => {
      const r = computeRowResult(row, idx);

      const rc = document.createElement("div");
      rc.className = "rowCard" + (state.lastAddedRowIndex === idx ? " flash" : "");
      rc.id = `row_${idx}`;

      rc.innerHTML = `
        <div class="rowHeader">
          <div class="rowTitle">Row ${idx+1}</div>
          <span class="chip">${(r.status==="ok" || r.status==="push") ? "Auto" : "Pending"}</span>
        </div>

        <div class="teams">
          <div>
            <div class="sideLabel">
              <label style="margin:0;">Team A (left)</label>
              <div class="sideTools">
                <button class="miniBtn" type="button" data-act="usePrevA">Use prev A</button>
              </div>
            </div>
            <div class="acWrap">
              <textarea id="a_${idx}" placeholder="Zack, Keith  (comma separated)">${row.a || ""}</textarea>
            </div>
            <div class="hint">Autocomplete blocks names already used on Team B (same row).</div>
          </div>

          <div>
            <div class="sideLabel">
              <label style="margin:0;">Team B (right)</label>
              <div class="sideTools">
                <button class="miniBtn" type="button" data-act="usePrevB">Use prev B</button>
              </div>
            </div>
            <div class="acWrap">
              <textarea id="b_${idx}" placeholder="Brad, Dawson  (comma separated)">${row.b || ""}</textarea>
            </div>
            <div class="hint">Shortcut: type "" to reuse previous row on that side.</div>
          </div>
        </div>

        <div class="resultBox" id="res_${idx}"></div>

        <div class="rowActions">
          <button class="btn btnPrimary" type="button" data-act="addNextBlank">Add Next Row</button>
          <button class="btn btnPrimary" type="button" data-act="addNextReuseA">Add Next (reuse Team A)</button>
          <button class="btn btnDanger" type="button" data-act="deleteRow">Delete</button>
        </div>
      `;

      rowsList.appendChild(rc);

      // render result text
      const res = $(`res_${idx}`);
      if(r.status === "need_csv"){
        res.innerHTML = `
          <div class="resultTop">
            <div class="winner push">Need Squabbit CSV</div>
            <div class="bigMoney">—</div>
          </div>
          <div class="muted">Load the Squabbit export once at the top.</div>
        `;
      } else if(r.status === "need_names"){
        res.innerHTML = `
          <div class="resultTop">
            <div class="winner push">Need names / match CSV</div>
            <div class="bigMoney">—</div>
          </div>
          <div class="muted">Use names exactly as in the Squabbit export. Autocomplete helps.</div>
        `;
      } else if(r.status === "invalid"){
        res.innerHTML = `
          <div class="resultTop">
            <div class="winner push">Fix this row</div>
            <div class="bigMoney">—</div>
          </div>
          <div class="errorLine">${r.message}</div>
        `;
      } else if(r.status === "push"){
        res.innerHTML = `
          <div class="resultTop">
            <div class="winner push">Push</div>
            <div class="bigMoney">$0.00</div>
          </div>
          <div class="muted">Team A: <b>${r.aScore}</b> • Team B: <b>${r.bScore}</b></div>
        `;
      } else {
        res.innerHTML = `
          <div class="resultTop">
            <div class="winner ${r.aWins ? "good" : "bad"}">${r.aWins ? "Team A wins" : "Team B wins"} by ${r.margin}</div>
            <div class="bigMoney">Each loser owes $${money(r.payout.perLoser)}</div>
          </div>
          <div class="muted">
            Team A score: <b>${r.aScore}</b> • Team B score: <b>${r.bScore}</b><br>
            Shots used: <b>${r.payout.shots}</b> (cap ${state.maxShots}) • Total paid: <b>$${money(r.payout.total)}</b><br>
            Winners split: <b>$${money(r.payout.perWinner)}</b> each<br>
            Winners: <b>${r.winners.join(", ")}</b><br>
            Losers: <b>${r.losers.join(", ")}</b>
          </div>
        `;
      }

      // wire inputs + autocomplete with cross-team blocking
      const aEl = $(`a_${idx}`);
      const bEl = $(`b_${idx}`);

      const getNames = () => getNameList();

      makeAutocomplete(
        aEl,
        getNames,
        () => teamKeys(parseTeamInput(bEl.value || "")),
        (picked) => {
          aEl.value = appendNameWithComma(aEl.value, picked);
          state.rows[idx].a = aEl.value;
          saveState(state);
          renderRows();
        }
      );

      makeAutocomplete(
        bEl,
        getNames,
        () => teamKeys(parseTeamInput(aEl.value || "")),
        (picked) => {
          bEl.value = appendNameWithComma(bEl.value, picked);
          state.rows[idx].b = bEl.value;
          saveState(state);
          renderRows();
        }
      );

      aEl.addEventListener("input", () => {
        state.rows[idx].a = aEl.value;
        saveState(state);
        updateSummary();
      });
      bEl.addEventListener("input", () => {
        state.rows[idx].b = bEl.value;
        saveState(state);
        updateSummary();
      });

      // row buttons
      rc.querySelectorAll("button[data-act]").forEach(btn => {
        btn.onclick = () => {
          const act = btn.getAttribute("data-act");
          const prev = state.rows[idx - 1];

          if(act === "usePrevA" && prev){
            state.rows[idx].a = prev.a;
            saveState(state);
            renderRows();
            return;
          }
          if(act === "usePrevB" && prev){
            state.rows[idx].b = prev.b;
            saveState(state);
            renderRows();
            return;
          }
          if(act === "deleteRow"){
            state.rows.splice(idx, 1);
            saveState(state);
            renderRows();
            return;
          }
          if(act === "addNextBlank"){
            const newIndex = idx + 1;
            state.rows.splice(newIndex, 0, { a:"", b:"" });
            state.lastAddedRowIndex = newIndex;
            saveState(state);
            renderRows();
            setTimeout(() => {
              const el = document.getElementById(`b_${newIndex}`);
              if(el) el.focus();
              const rowEl = document.getElementById(`row_${newIndex}`);
              if(rowEl) rowEl.scrollIntoView({ behavior:"smooth", block:"center" });
              state.lastAddedRowIndex = null;
              saveState(state);
            }, 80);
            return;
          }
          if(act === "addNextReuseA"){
            const newIndex = idx + 1;
            state.rows.splice(newIndex, 0, { a: state.rows[idx].a, b:"" });
            state.lastAddedRowIndex = newIndex;
            saveState(state);
            renderRows();
            setTimeout(() => {
              const el = document.getElementById(`b_${newIndex}`);
              if(el) el.focus();
              const rowEl = document.getElementById(`row_${newIndex}`);
              if(rowEl) rowEl.scrollIntoView({ behavior:"smooth", block:"center" });
              state.lastAddedRowIndex = null;
              saveState(state);
            }, 80);
            return;
          }
        };
      });
    });

    updateSummary();
  }

  // --------- controls ----------
  function addRow(){
    const idx = state.rows.length;
    state.rows.push({ a:"", b:"" });
    state.lastAddedRowIndex = idx;
    saveState(state);
    renderRows();
    setTimeout(() => {
      const el = document.getElementById(`a_${idx}`);
      if(el) el.focus();
      const rowEl = document.getElementById(`row_${idx}`);
      if(rowEl) rowEl.scrollIntoView({ behavior:"smooth", block:"center" });
      state.lastAddedRowIndex = null;
      saveState(state);
    }, 80);
  }

  $("addRowBtn").onclick = addRow;

  $("clearSheetBtn").onclick = () => {
    const ok = confirm("Clear the sheet rows?\n\n(This does not delete the CSV.)");
    if(!ok) return;
    state.rows = [];
    saveState(state);
    renderRows();
  };

  $("filterInput").addEventListener("input", renderRows);

  $("dollarsPerShot").addEventListener("input", () => {
    const v = Number($("dollarsPerShot").value);
    state.dollarsPerShot = Number.isFinite(v) && v >= 0 ? Math.round(v) : 5;
    saveState(state);
    renderRows();
  });

  $("maxShots").addEventListener("input", () => {
    const v = Number($("maxShots").value);
    state.maxShots = Number.isFinite(v) && v >= 1 ? Math.round(v) : 5; // min 1
    $("maxShots").value = state.maxShots;
    saveState(state);
    renderRows();
  });

  $("csvInput").addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if(!file) return;
    const txt = await file.text();
    const players = parsePlayersFromSquabbitCSV(txt);

    if(!players.length){
      setCSVStatus("Could not find player hole scores. Make sure this is the Squabbit export with Hole 1–18.");
      return;
    }

    state.players = players;
    state.csvLoadedAt = new Date().toISOString();
    saveState(state);
    setCSVStatus(`Loaded ${players.length} player(s) from Squabbit export.`);
    renderRows();
  });

  // --------- copy / export ----------
  $("copySummaryBtn").onclick = async () => {
    try{
      await navigator.clipboard.writeText($("summaryText").textContent || "");
      alert("Copied payout summary.");
    } catch {
      alert("Copy failed on this device. You can manually select and copy.");
    }
  };

  $("downloadSheetBtn").onclick = () => {
    const lines = [];
    lines.push(["Row","Team A","Team B","Team A Score","Team B Score","Winner","Margin","ShotsUsed","EachLoserOwes","EachWinnerGets","TotalPaid"].join(","));

    state.rows.forEach((row, idx) => {
      const r = computeRowResult(row, idx);
      const safe = (s) => `"${String(s || "").replace(/"/g,'""')}"`;

      if(r.status === "need_csv" || r.status === "need_names" || r.status === "invalid"){
        lines.push([idx+1, safe(row.a), safe(row.b), "", "", r.status, "", "", "", "", ""].join(","));
        return;
      }
      if(r.status === "push"){
        lines.push([idx+1, safe(row.a), safe(row.b), r.aScore, r.bScore, "Push", 0, 0, 0, 0, 0].join(","));
        return;
      }
      lines.push([
        idx+1, safe(row.a), safe(row.b),
        r.aScore, r.bScore,
        r.aWins ? "Team A" : "Team B",
        r.margin,
        r.payout.shots,
        money(r.payout.perLoser),
        money(r.payout.perWinner),
        money(r.payout.total)
      ].join(","));
    });

    const blob = new Blob([lines.join("\n")], { type:"text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "bestball_bet_sheet.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  };

  // --------- bottom bar ----------
  (function(){
    $("hubToolTitle").textContent = window.TOOL_NAME || document.title || "Golf Tool";

    $("hubBackBtn").onclick = () => { window.location.href = window.HUB_INDEX || "index.html"; };

    $("hubResetThisBtn").onclick = () => {
      const keys = Array.isArray(window.TOOL_STORAGE_KEYS) ? window.TOOL_STORAGE_KEYS : [];
      if(!keys.length) return alert("No reset keys set for this tool yet.");
      const ok = confirm(`Reset this tool?\n\nThis clears:\n- ${keys.join("\n- ")}`);
      if(!ok) return;
      keys.forEach(k => localStorage.removeItem(k));
      alert("Tool reset. Reloading…");
      window.location.reload();
    };

    $("hubResetAllBtn").onclick = () => {
      const ok = confirm("Reset EVERYTHING for this site on this device?\n\nThis clears all local saved data.");
      if(!ok) return;
      localStorage.clear();
      alert("Everything reset. Returning to hub…");
      window.location.href = window.HUB_INDEX || "index.html";
    };
  })();

  // --------- init ----------
  function init(){
    clampSettings();
    $("dollarsPerShot").value = state.dollarsPerShot;
    $("maxShots").value = state.maxShots;

    if(state.players?.length){
      setCSVStatus(`Loaded ${state.players.length} player(s) from Squabbit export.`);
    } else {
      setCSVStatus("No CSV loaded yet.");
    }
    renderRows();
  }

  init();
})();
</script>
</body>
</html>
