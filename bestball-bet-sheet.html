<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Best Ball Bet Sheet</title>
  <style>
    :root{
      --bg0:#07110d;
      --bg1:#0b1f16;
      --text:#eaf5ef;
      --muted:#b7d1c2;
      --line:rgba(255,255,255,.10);

      --accent:#34d399;
      --accent2:#22c55e;
      --warn:#fbbf24;
      --bad:#fb7185;
      --mid:#94a3b8;

      --shadow: 0 14px 45px rgba(0,0,0,.45);
      --radius: 16px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      color:var(--text);
      font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 800px at 20% 0%, rgba(52,211,153,.20), transparent 55%),
        radial-gradient(900px 600px at 90% 10%, rgba(251,191,36,.16), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, #06110c);
      padding: 16px 16px 90px; /* room for bottom sticky bar */
    }
    .wrap{ max-width: 980px; margin: 0 auto; }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      margin: 12px 0;
    }
    .topline{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      margin: 0 0 10px; color: var(--muted); font-size: 12px;
    }
    .tag{
      display:inline-block;
      padding: 2px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color: var(--muted);
      font-size: 12px;
      white-space:nowrap;
    }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .grid3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    @media (max-width: 780px){
      .grid2, .grid3{ grid-template-columns: 1fr; }
    }

    label{ display:block; margin: 10px 0 6px; color: var(--muted); font-size: 12.5px; }
    input, select, button, textarea{
      font-family: inherit;
    }
    input, select{
      width:100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(9, 24, 17, .55);
      color: var(--text);
      outline: none;
      font-size: 16px;
    }
    select{
      appearance:none;
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(234,245,239,.75) 50%),
        linear-gradient(135deg, rgba(234,245,239,.75) 50%, transparent 50%);
      background-position: calc(100% - 18px) 50%, calc(100% - 12px) 50%;
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
      padding-right: 34px;
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
    .btn{
      border:0;
      border-radius: 14px;
      padding: 12px 14px;
      font-size: 16px;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, filter .15s ease;
    }
    .btn:active{ transform: scale(.99); }
    .btnFull{ width:100%; }
    .btnPrimary{ color:#0b1510; background: linear-gradient(135deg, var(--accent2), var(--accent)); box-shadow: 0 12px 30px rgba(34,197,94,.25); }
    .btnGhost{ background: rgba(255,255,255,.08); color: var(--text); border: 1px solid var(--line); font-weight:900; }
    .btnWarn{ color:#0b1510; background: linear-gradient(135deg, #fbbf24, #f59e0b); box-shadow: 0 12px 30px rgba(245,158,11,.18); }
    .btnBad{ color:#0b1510; background: linear-gradient(135deg, #fb7185, #ef4444); box-shadow: 0 12px 30px rgba(239,68,68,.20); }
    .btnMid{ color:#0b1510; background: linear-gradient(135deg, #94a3b8, #cbd5e1); }

    .mini{ font-size:12px; color: var(--muted); margin-top: 8px; line-height:1.35; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; }

    /* Team entry chips + autocomplete */
    .teamBox{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(9, 24, 17, .55);
      border-radius: 14px;
      padding: 10px;
    }
    .chips{ display:flex; flex-wrap:wrap; gap:8px; margin-bottom:8px; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:900;
      font-size: 14px;
    }
    .chip button{
      border:0; cursor:pointer;
      border-radius: 10px;
      padding: 2px 8px;
      font-weight: 950;
      background: rgba(255,255,255,.10);
      color: var(--text);
    }
    .chip button:active{ transform: scale(.99); }

    .acWrap{ position: relative; }
    .acList{
      position:absolute; left:0; right:0; top: calc(100% + 6px);
      background: rgba(10, 26, 18, .98);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      overflow:hidden;
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
      z-index: 50;
      max-height: 220px;
      overflow-y: auto;
    }
    .acItem{
      padding: 10px 12px;
      font-weight: 900;
      border-bottom: 1px solid rgba(255,255,255,.08);
      cursor:pointer;
    }
    .acItem:last-child{ border-bottom:0; }
    .acItem:hover{ background: rgba(255,255,255,.06); }
    .acNote{ padding: 10px 12px; color: var(--muted); font-size: 12px; }

    /* Matchup rows (collapsed summary) */
    .rowCard{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.18);
      padding: 12px;
      margin-top: 10px;
    }
    .rowTop{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .rowTitle{
      font-weight: 950;
      font-size: 15px;
      line-height:1.25;
    }
    .rowSub{
      margin-top:6px;
      color: var(--muted);
      font-size: 12px;
      line-height:1.35;
    }
    .payoutBig{
      margin-top: 8px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 950;
      font-size: 14px;
      line-height:1.35;
    }
    .good{ color:#5eead4; font-weight:950; }
    .bad{ color:#fda4af; font-weight:950; }
    .warn{ color:#fde68a; font-weight:950; }

    .divider{ height:1px; background: rgba(255,255,255,.10); margin: 12px 0; }

    /* Bottom sticky bar (hub controls) */
    .hubbar{
      position: fixed;
      left:0; right:0; bottom:0;
      z-index: 9999;
      padding: 10px 12px;
      background: linear-gradient(180deg, rgba(5,17,11,.70), rgba(5,17,11,.92));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255,255,255,.10);
    }
    .hubbarRow{
      max-width: 980px;
      margin: 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .hubbarTitle{
      color: #eaf5ef;
      font-weight: 950;
      font-size: 13px;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 40vw;
    }
    .hubBtns{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .hubBtn{
      border:0;
      border-radius: 12px;
      padding: 9px 10px;
      font-size: 13px;
      font-weight: 950;
      cursor:pointer;
      user-select:none;
    }
    .hubBtnGhost{
      background: rgba(255,255,255,.08);
      color:#eaf5ef;
      border: 1px solid rgba(255,255,255,.10);
    }
    .hubBtnDanger{
      background: linear-gradient(135deg, #fb7185, #ef4444);
      color:#08110c;
    }
  </style>
</head>

<body>
<div class="wrap">

  <div class="card" id="setupCard">
    <div class="topline">
      <span>Best Ball Bet Sheet</span>
      <span class="tag" id="statusTag">No round loaded</span>
    </div>

    <div class="mini">
      Upload your <b>Squabbit export CSV</b> once. Then build matchups.
      Winner/payouts are calculated automatically. Saved locally on this device.
    </div>

    <label>1) Upload Squabbit CSV</label>
    <input id="csvInput" type="file" accept=".csv,text/csv" />

    <div class="grid3" style="margin-top:10px;">
      <div>
        <label>$ per stroke (uniform)</label>
        <input id="perStroke" type="number" min="1" step="1" value="5" />
      </div>
      <div>
        <label>Max $ per person (uniform)</label>
        <input id="maxPerPerson" type="number" min="1" step="1" value="25" />
      </div>
      <div>
        <label>Holes counted</label>
        <select id="holesCounted">
          <option value="18" selected>18 holes</option>
          <option value="9">Front 9 only</option>
          <option value="9b">Back 9 only</option>
        </select>
      </div>
    </div>

    <div class="grid2" style="margin-top:10px;">
      <div>
        <label>Find player on sheet</label>
        <input id="findPlayer" placeholder="Type a name…" />
        <div class="mini" id="findResult"> </div>
      </div>
      <div>
        <label>Quick actions</label>
        <div class="btnRow">
          <button class="btn btnGhost" id="copyLastBtn" type="button">Copy last matchup</button>
          <button class="btn btnPrimary" id="addRowBtn" type="button">Add next row</button>
        </div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="topline">
      <span>Wheel Bet (optional)</span>
      <span class="tag">Anchor team vs every 2-man combo</span>
    </div>

    <div class="grid2">
      <div class="card" style="margin:0; padding:12px;">
        <div class="topline"><span>Anchor Team (usually 2)</span><span class="tag">Best ball</span></div>
        <div id="anchorTeamUI"></div>
      </div>
      <div class="card" style="margin:0; padding:12px;">
        <div class="topline"><span>Include / Exclude players</span><span class="tag">OUT removes from combos</span></div>
        <div id="wheelPoolUI"></div>
      </div>
    </div>

    <div class="btnRow" style="margin-top:10px;">
      <button class="btn btnWarn btnFull" id="runWheelBtn" type="button">Run Wheel (generate matchups)</button>
    </div>

    <div class="mini" id="wheelHint">
      Wheel creates rows where your anchor team plays every 2-man combo from the remaining included players.
    </div>
  </div>

  <div class="card" id="entryCard" style="display:none;">
    <div class="topline">
      <span>Enter Matchup</span>
      <span class="tag" id="entryModeTag">New row</span>
    </div>

    <div class="grid2">
      <div>
        <label>Left Team (1–3 players)</label>
        <div id="teamAUI"></div>
      </div>
      <div>
        <label>Right Team (1–3 players)</label>
        <div id="teamBUI"></div>
      </div>
    </div>

    <div class="btnRow" style="margin-top:10px;">
      <button class="btn btnPrimary" id="saveRowBtn" type="button">Save matchup</button>
      <button class="btn btnGhost" id="cancelEntryBtn" type="button">Cancel</button>
    </div>

    <div class="mini" id="entryHelp">
      Tip: type a name and tap it. After adding a name, you can immediately search the next name.
      No side scrolling. Names cannot be duplicated inside the same matchup.
    </div>
  </div>

  <div class="card" id="rowsCard">
    <div class="topline">
      <span>Matchups</span>
      <span class="tag" id="rowsCountTag">0 rows</span>
    </div>

    <div id="rowsList"></div>
  </div>

  <div class="card" id="totalsCard">
    <div class="topline">
      <span>Net Totals (everyone)</span>
      <span class="tag">$ shown is net</span>
    </div>
    <div id="totalsTable"></div>
    <div class="mono mini" id="settlementText" style="margin-top:10px;"></div>
  </div>

</div>
<div class="hubbar">
  <div class="hubbarRow">
    <div class="hubbarTitle" id="hubToolTitle">Best Ball Bet Sheet</div>
    <div class="hubBtns">
      <button class="hubBtn hubBtnGhost" type="button" id="hubBackBtn">← Back to Hub</button>
      <button class="hubBtn hubBtnGhost" type="button" id="hubResetThisBtn">Reset This Tool</button>
      <button class="hubBtn hubBtnDanger" type="button" id="hubResetAllBtn">Reset Everything</button>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== CONFIG ======
  window.TOOL_NAME = "Bet Sheet";
  window.TOOL_STORAGE_KEYS = ["bb_betsheet_v1"];   // reset this tool
  window.HUB_INDEX = "index.html";                // back to hub

  const LS_KEY = "bb_betsheet_v1";
  const $ = (id) => document.getElementById(id);

  // ====== STATE ======
  let players = [];          // [{name, strokes[18], front, back, total}]
  let playerNames = [];      // [string]
  let rows = [];             // [{id, teamA:[names], teamB:[names]}] (collapsed always; edit reopens)
  let lastRow = null;        // {teamA, teamB}
  let editingRowId = null;   // id if editing
  let wheelOut = new Set();  // names excluded from wheel
  let anchorTeam = [];       // names (1-3 allowed, but wheel assumes 2 as typical)

  // ====== HELPERS ======
  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const norm = (s) => (s || "").toString().trim().toLowerCase();

  function loadSaved(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      return JSON.parse(raw);
    }catch(e){ return null; }
  }
  function save(){
    const payload = {
      players,                // keep parsed players so you do not need re-upload
      rows,
      lastRow,
      wheelOut: [...wheelOut],
      anchorTeam,
      settings: getSettings(),
      savedAt: new Date().toISOString()
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
  }
  function restore(saved){
    players = saved.players || [];
    playerNames = (players || []).map(p => p.name).sort((a,b)=>a.localeCompare(b));
    rows = saved.rows || [];
    lastRow = saved.lastRow || null;
    wheelOut = new Set(saved.wheelOut || []);
    anchorTeam = saved.anchorTeam || [];
    if(saved.settings){
      $("perStroke").value = saved.settings.perStroke;
      $("maxPerPerson").value = saved.settings.maxPerPerson;
      $("holesCounted").value = saved.settings.holesCounted;
    }
  }

  function getSettings(){
    const perStroke = clamp(parseInt($("perStroke").value || "5", 10) || 5, 1, 9999);
    const maxPerPerson = clamp(parseInt($("maxPerPerson").value || "25", 10) || 25, 1, 9999);
    const holesCounted = $("holesCounted").value || "18"; // 18 | 9 | 9b
    return { perStroke, maxPerPerson, holesCounted };
  }

  // ====== CSV PARSER (Squabbit-style) ======
  const splitCSVLine = (line) => {
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i = 0; i < line.length; i++) {
      const c = line[i];
      if (c === '"') {
        if (inQ && line[i + 1] === '"') { cur += '"'; i++; }
        else inQ = !inQ;
      } else if (c === ',' && !inQ) {
        out.push(cur);
        cur = "";
      } else {
        cur += c;
      }
    }
    out.push(cur);
    return out.map(s => (s || "").trim());
  };
  const parseCSVRows = (text) => text.split(/\r?\n/).map(splitCSVLine);
  const toInt = (v) => {
    const s = (v ?? "").toString().trim();
    if (!/^\d+$/.test(s)) return null;
    const n = parseInt(s, 10);
    return Number.isFinite(n) ? n : null;
  };
  const titleCase = (n) => n.split(/\s+/).map(w => w ? (w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()) : "").join(" ").trim();
  const buildHoleIndex = (row) => {
    const idx = {};
    row.forEach((c, i) => {
      const s = (c || "").toLowerCase().trim();
      for (let h = 1; h <= 18; h++) {
        if (s === `hole ${h}` || s === `${h}` || s === `hole${h}`) idx[h] = i;
      }
    });
    return Object.keys(idx).length ? idx : null;
  };
  const isPlayerRow = (r) => (r[1] || "").toLowerCase().includes("tee") && (r[0] || "").trim();

  function parsePlayersFromCSV(txt){
    const rows = parseCSVRows(txt);
    let holeIdx = null;
    const playersMap = new Map();

    for (const row of rows) {
      if (row.some(c => /hole\s*1/i.test(c || ""))) {
        holeIdx = buildHoleIndex(row);
        continue;
      }
      if (!holeIdx) continue;

      const lowerJoined = row.map(c => (c || "").toLowerCase()).join(" ");
      if (
        lowerJoined.includes("individual gross skins") ||
        lowerJoined.includes("strokeplay") ||
        lowerJoined.includes("best ball") ||
        lowerJoined.includes("par") ||
        lowerJoined.startsWith("s.i.")
      ) continue;

      if (!isPlayerRow(row)) continue;

      const rawName = (row[0] || "").trim();
      if (!rawName) continue;

      const name = titleCase(rawName);
      const strokes = [];
      for (let h = 1; h <= 18; h++) {
        const col = holeIdx[h];
        const val = col != null ? toInt(row[col]) : null;
        if (val == null) { strokes.length = 0; break; }
        strokes.push(val);
      }

      if (strokes.length === 18) {
        const front = strokes.slice(0,9).reduce((a,b)=>a+b,0);
        const back  = strokes.slice(9,18).reduce((a,b)=>a+b,0);
        const total = front + back;
        playersMap.set(name, { name, strokes, front, back, total });
      }
    }
    return [...playersMap.values()];
  }

  function findPlayerObj(name){
    const n = norm(name);
    return players.find(p => norm(p.name) === n) || null;
  }

  // Team best ball score:
  // holesCounted:
  // - "18": all
  // - "9": front 9
  // - "9b": back 9
  function teamBestBallScore(teamNames, holesCounted){
    const teamObjs = teamNames.map(findPlayerObj).filter(Boolean);
    if(teamObjs.length !== teamNames.length) return null;

    let start = 0, end = 18;
    if(holesCounted === "9"){ start = 0; end = 9; }
    if(holesCounted === "9b"){ start = 9; end = 18; }

    let sum = 0;
    for(let i=start; i<end; i++){
      let best = Infinity;
      for(const p of teamObjs){
        best = Math.min(best, p.strokes[i]);
      }
      if(!Number.isFinite(best)) return null;
      sum += best;
    }
    return sum;
  }

  // payout:
  // diff strokes * perStroke, capped per person
  // losers each pay same
  // winners split total equally (balanced for 2v1, 3v2, etc)
  function calcMatchup(teamA, teamB){
    const { perStroke, maxPerPerson, holesCounted } = getSettings();
    const scoreA = teamBestBallScore(teamA, holesCounted);
    const scoreB = teamBestBallScore(teamB, holesCounted);

    if(scoreA == null || scoreB == null) {
      return { ok:false, msg:"Missing player scores (upload CSV, and use names from the CSV list)." };
    }

    const aSize = teamA.length;
    const bSize = teamB.length;

    // lower score wins
    let winner = null;
    let loser = null;
    let winScore = null;
    let loseScore = null;

    if(scoreA < scoreB){ winner="A"; loser="B"; winScore=scoreA; loseScore=scoreB; }
    else if(scoreB < scoreA){ winner="B"; loser="A"; winScore=scoreB; loseScore=scoreA; }
    else { winner="TIE"; }

    const diff = Math.abs(scoreA - scoreB);

    if(winner === "TIE"){
      return {
        ok:true,
        winner,
        diff:0,
        scoreA, scoreB,
        perLoser:0,
        perWinner:0,
        total:0
      };
    }

    const loserCount = (loser === "A") ? aSize : bSize;
    const winnerCount = (winner === "A") ? aSize : bSize;

    const raw = diff * perStroke;
    const perLoser = Math.min(raw, maxPerPerson);
    const total = perLoser * loserCount;
    const perWinner = winnerCount ? (total / winnerCount) : 0;

    return {
      ok:true,
      winner,
      diff,
      scoreA, scoreB,
      perLoser,
      perWinner,
      total
    };
  }

  function fmtMoney(n){
    if(!Number.isFinite(n)) return "$0";
    const sign = n > 0 ? "+" : (n < 0 ? "−" : "");
    const abs = Math.abs(n);
    // show .50 etc if uneven split
    const txt = abs % 1 === 0 ? abs.toFixed(0) : abs.toFixed(2);
    return `${sign}$${txt}`;
  }

  // ====== AUTOCOMPLETE TEAM INPUT (chips) ======
  function buildTeamPicker(mountId, options){
    // options: { title, onChange(teamNames), maxPlayers, disallowSetProvider: ()=>Set(names) }
    const mount = document.getElementById(mountId);
    mount.innerHTML = "";

    const box = document.createElement("div");
    box.className = "teamBox";

    const chips = document.createElement("div");
    chips.className = "chips";

    const acWrap = document.createElement("div");
    acWrap.className = "acWrap";

    const input = document.createElement("input");
    input.type = "text";
    input.placeholder = players.length ? "Start typing a name…" : "Upload CSV first…";
    input.disabled = players.length === 0;

    const list = document.createElement("div");
    list.className = "acList";
    list.style.display = "none";

    let team = [];

    function emit(){
      options.onChange([...team]);
    }

    function renderChips(){
      chips.innerHTML = "";
      team.forEach(n => {
        const c = document.createElement("span");
        c.className = "chip";
        c.textContent = n;

        const x = document.createElement("button");
        x.type = "button";
        x.textContent = "x";
        x.onclick = () => {
          team = team.filter(v => v !== n);
          renderChips();
          emit();
        };

        c.appendChild(x);
        chips.appendChild(c);
      });
    }

    function openList(items){
      list.innerHTML = "";
      if(!items.length){
        const note = document.createElement("div");
        note.className = "acNote";
        note.textContent = "No matches.";
        list.appendChild(note);
      } else {
        items.forEach(name => {
          const it = document.createElement("div");
          it.className = "acItem";
          it.textContent = name;
          it.onclick = () => addName(name);
          list.appendChild(it);
        });
      }
      list.style.display = "block";
    }

    function closeList(){
      list.style.display = "none";
    }

    function addName(name){
      if(team.includes(name)) return;
      if(team.length >= (options.maxPlayers || 3)) return;

      const dis = options.disallowSetProvider ? options.disallowSetProvider() : new Set();
      if(dis.has(name)){
        alert("That name is already used on the other team for this matchup.");
        return;
      }

      team.push(name);
      renderChips();
      emit();

      input.value = "";      // "auto comma" behavior: you just keep adding
      closeList();
      input.focus();
    }

    function filterItems(q){
      const query = norm(q);
      const dis = options.disallowSetProvider ? options.disallowSetProvider() : new Set();
      const taken = new Set(team);

      return playerNames
        .filter(n => !taken.has(n))
        .filter(n => !dis.has(n))
        .filter(n => !query || norm(n).includes(query))
        .slice(0, 12);
    }

    input.addEventListener("input", () => {
      const items = filterItems(input.value);
      openList(items);
    });

    input.addEventListener("focus", () => {
      const items = filterItems(input.value);
      openList(items);
    });

    input.addEventListener("blur", () => {
      setTimeout(closeList, 120);
    });

    acWrap.appendChild(input);
    acWrap.appendChild(list);

    box.appendChild(chips);
    box.appendChild(acWrap);
    mount.appendChild(box);

    return {
      setTeam(names){
        team = [...names].filter(Boolean).slice(0, options.maxPlayers || 3);
        renderChips();
        emit();
      },
      getTeam(){ return [...team]; },
      focus(){ input.focus(); }
    };
  }

  // ====== RENDER: ROWS + TOTALS ======
  function computeNetTotals(){
    // returns {name: dollarsNet}
    const net = {};
    playerNames.forEach(n => net[n] = 0);

    for(const r of rows){
      const res = calcMatchup(r.teamA, r.teamB);
      if(!res.ok) continue;
      if(res.winner === "TIE") continue;

      const winTeam = (res.winner === "A") ? r.teamA : r.teamB;
      const loseTeam = (res.winner === "A") ? r.teamB : r.teamA;

      // losers each lose perLoser
      loseTeam.forEach(n => { if(net[n] != null) net[n] -= res.perLoser; });
      // winners each win perWinner (balanced)
      winTeam.forEach(n => { if(net[n] != null) net[n] += res.perWinner; });
    }
    return net;
  }

  function renderTotals(){
    if(!playerNames.length){
      $("totalsTable").innerHTML = `<div class="mini">Upload a Squabbit CSV to populate players and totals.</div>`;
      $("settlementText").textContent = "";
      return;
    }

    const net = computeNetTotals();
    const rowsSorted = Object.keys(net).map(n => ({ name:n, amt: net[n] }))
      .sort((a,b)=> b.amt - a.amt || a.name.localeCompare(b.name));

    let html = `<div class="rowCard">
      <div class="rowTitle">Net totals</div>
      <div class="rowSub">Positive means they are owed money. Negative means they owe money.</div>
      <div class="divider"></div>
    `;

    rowsSorted.forEach(r => {
      const cls = r.amt >= 0 ? "good" : "bad";
      html += `<div style="display:flex; justify-content:space-between; gap:10px; padding:8px 0; border-bottom:1px solid rgba(255,255,255,.08);">
        <div style="font-weight:950;">${r.name}</div>
        <div class="${cls}" style="font-weight:950; font-size:16px;">${fmtMoney(r.amt)}</div>
      </div>`;
    });

    html += `</div>`;
    $("totalsTable").innerHTML = html;

    // settlement suggestions (simple greedy)
    const creditors = rowsSorted.filter(r => r.amt > 0).map(r => ({...r}));
    const debtors = rowsSorted.filter(r => r.amt < 0).map(r => ({...r, amt: -r.amt}));

    let i=0, j=0;
    const lines = [];
    while(i<debtors.length && j<creditors.length){
      const pay = Math.min(debtors[i].amt, creditors[j].amt);
      if(pay > 0.009){
        const txt = (pay % 1 === 0) ? pay.toFixed(0) : pay.toFixed(2);
        lines.push(`${debtors[i].name} pays ${creditors[j].name}: $${txt}`);
        debtors[i].amt -= pay;
        creditors[j].amt -= pay;
      }
      if(debtors[i].amt <= 0.009) i++;
      if(creditors[j].amt <= 0.009) j++;
    }
    $("settlementText").textContent = "Settlement:\n" + (lines.length ? lines.join("\n") : "All square.");
  }

  function rowSummaryText(r){
    const res = calcMatchup(r.teamA, r.teamB);
    if(!res.ok) return { title: `${r.teamA.join(", ")} vs ${r.teamB.join(", ")}`, sub: res.msg, payout: "" };

    const left = r.teamA.join(", ");
    const right = r.teamB.join(", ");
    const { holesCounted, perStroke, maxPerPerson } = getSettings();

    const holesLabel = (holesCounted === "18") ? "18" : (holesCounted === "9" ? "Front 9" : "Back 9");
    const scoreLine = `Scores (${holesLabel}): Left ${res.scoreA} | Right ${res.scoreB}`;

    if(res.winner === "TIE"){
      return {
        title: `${left} vs ${right}`,
        sub: `${scoreLine} • Tie`,
        payout: `Push: $0`
      };
    }

    const winSide = (res.winner === "A") ? "Left" : "Right";
    const loseSide = (res.winner === "A") ? "Right" : "Left";

    const perLoserTxt = (res.perLoser % 1 === 0) ? res.perLoser.toFixed(0) : res.perLoser.toFixed(2);
    const perWinnerTxt = (res.perWinner % 1 === 0) ? res.perWinner.toFixed(0) : res.perWinner.toFixed(2);
    const totalTxt = (res.total % 1 === 0) ? res.total.toFixed(0) : res.total.toFixed(2);

    const payout =
      `Winner: ${winSide} • By ${res.diff} stroke(s)\n` +
      `Each losing player pays: $${perLoserTxt} (cap $${maxPerPerson})\n` +
      `Each winning player receives: $${perWinnerTxt}\n` +
      `Total moved: $${totalTxt} • Rate: $${perStroke}/stroke`;

    return {
      title: `${left} vs ${right}`,
      sub: `${scoreLine} • Winner: ${winSide} by ${res.diff}`,
      payout
    };
  }

  function renderRows(){
    $("rowsCountTag").textContent = `${rows.length} row${rows.length === 1 ? "" : "s"}`;
    const list = $("rowsList");
    list.innerHTML = "";

    if(!rows.length){
      list.innerHTML = `<div class="mini">No matchups yet. Tap “Add next row”.</div>`;
      renderTotals();
      return;
    }

    rows.forEach((r, idx) => {
      const box = document.createElement("div");
      box.className = "rowCard";

      const sum = rowSummaryText(r);

      const top = document.createElement("div");
      top.className = "rowTop";

      const left = document.createElement("div");
      left.style.flex = "1";
      left.innerHTML = `
        <div class="rowTitle">Row ${idx+1}: ${sum.title}</div>
        <div class="rowSub">${sum.sub}</div>
      `;

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.gap = "8px";
      right.style.flexWrap = "wrap";
      right.style.justifyContent = "flex-end";

      const editBtn = document.createElement("button");
      editBtn.className = "btn btnGhost";
      editBtn.type = "button";
      editBtn.textContent = "Edit";
      editBtn.onclick = () => openEntryForEdit(r.id);

      const dupBtn = document.createElement("button");
      dupBtn.className = "btn btnGhost";
      dupBtn.type = "button";
      dupBtn.textContent = "Duplicate";
      dupBtn.onclick = () => {
        const copy = { id: uid(), teamA: [...r.teamA], teamB: [...r.teamB] };
        rows.push(copy);
        lastRow = { teamA: [...copy.teamA], teamB: [...copy.teamB] };
        save();
        renderAll();
      };

      const delBtn = document.createElement("button");
      delBtn.className = "btn btnBad";
      delBtn.type = "button";
      delBtn.textContent = "Delete";
      delBtn.onclick = () => {
        const ok = confirm("Delete this row?");
        if(!ok) return;
        rows = rows.filter(x => x.id !== r.id);
        save();
        renderAll();
      };

      right.appendChild(editBtn);
      right.appendChild(dupBtn);
      right.appendChild(delBtn);

      top.appendChild(left);
      top.appendChild(right);

      const payout = document.createElement("div");
      payout.className = "payoutBig mono";
      payout.textContent = sum.payout || "";

      box.appendChild(top);
      if(sum.payout) box.appendChild(payout);

      list.appendChild(box);
    });

    renderTotals();
  }

  // ====== FIND PLAYER ======
  function updateFindPlayer(){
    const q = norm($("findPlayer").value);
    if(!q){
      $("findResult").textContent = " ";
      return;
    }
    const matches = playerNames.filter(n => norm(n).includes(q));
    if(!matches.length){
      $("findResult").textContent = "No matching player in the loaded round.";
      return;
    }

    const name = matches[0]; // first match
    const net = computeNetTotals();
    const amt = net[name] ?? 0;
    const cls = amt >= 0 ? "good" : "bad";
    $("findResult").innerHTML = `Found: <b>${name}</b> • Net: <span class="${cls}">${fmtMoney(amt)}</span>`;

    // highlight rows containing that player
    const cards = [...document.querySelectorAll("#rowsList .rowCard")];
    cards.forEach((c, i) => {
      const r = rows[i];
      const has = r.teamA.includes(name) || r.teamB.includes(name);
      c.style.outline = has ? "2px solid rgba(52,211,153,.45)" : "none";
    });
  }

  // ====== ENTRY (ADD / EDIT) ======
  let teamAPicker = null;
  let teamBPicker = null;

  function openEntry(newRow=true){
    $("entryCard").style.display = "block";
    $("entryModeTag").textContent = newRow ? "New row" : "Edit row";

    let teamA = [];
    let teamB = [];

    teamAPicker = buildTeamPicker("teamAUI", {
      maxPlayers: 3,
      disallowSetProvider: () => new Set(teamB)
      ,
      onChange: (names) => { teamA = names; }
    });

    teamBPicker = buildTeamPicker("teamBUI", {
      maxPlayers: 3,
      disallowSetProvider: () => new Set(teamA),
      onChange: (names) => { teamB = names; }
    });

    // if "copy last matchup" was pressed, lastRow will be set
    if(lastRow && newRow){
      teamAPicker.setTeam(lastRow.teamA || []);
      teamBPicker.setTeam(lastRow.teamB || []);
      teamA = teamAPicker.getTeam();
      teamB = teamBPicker.getTeam();
    }

    // if editing
    if(!newRow && editingRowId){
      const r = rows.find(x => x.id === editingRowId);
      if(r){
        teamAPicker.setTeam(r.teamA);
        teamBPicker.setTeam(r.teamB);
        teamA = teamAPicker.getTeam();
        teamB = teamBPicker.getTeam();
      }
    }

    setTimeout(()=>teamAPicker.focus(), 50);

    $("saveRowBtn").onclick = () => {
      if(players.length === 0){
        alert("Upload a Squabbit CSV first.");
        return;
      }
      if(teamA.length < 1 || teamB.length < 1){
        alert("Each side needs at least 1 player.");
        return;
      }
      if(teamA.length > 3 || teamB.length > 3){
        alert("Max 3 players per side.");
        return;
      }

      // prevent duplicates inside same matchup across both sides
      const dup = teamA.find(n => teamB.includes(n));
      if(dup){
        alert("Same player cannot be on both sides.");
        return;
      }

      // validate names exist in round
      for(const n of [...teamA, ...teamB]){
        if(!findPlayerObj(n)){
          alert(`Player not found in the loaded CSV: ${n}`);
          return;
        }
      }

      if(editingRowId){
        const idx = rows.findIndex(x => x.id === editingRowId);
        if(idx >= 0){
          rows[idx].teamA = [...teamA];
          rows[idx].teamB = [...teamB];
        }
        editingRowId = null;
      } else {
        rows.push({ id: uid(), teamA: [...teamA], teamB: [...teamB] });
      }

      lastRow = { teamA: [...teamA], teamB: [...teamB] };
      save();
      closeEntry();
      renderAll();
    };

    $("cancelEntryBtn").onclick = () => {
      editingRowId = null;
      closeEntry();
    };
  }

  function closeEntry(){
    $("entryCard").style.display = "none";
    $("teamAUI").innerHTML = "";
    $("teamBUI").innerHTML = "";
  }

  function openEntryForEdit(rowId){
    editingRowId = rowId;
    openEntry(false);
    window.scrollTo({ top: 0, behavior: "smooth" });
  }

  // ====== COPY LAST ======
  function copyLast(){
    if(!lastRow){
      alert("No previous matchup to copy yet.");
      return;
    }
    editingRowId = null;
    $("entryCard").style.display = "none";
    openEntry(true);
  }

  // ====== WHEEL MODE ======
  function buildWheelUI(){
    // anchor picker
    const anchorMount = $("anchorTeamUI");
    anchorMount.innerHTML = "";
    const anchorPicker = buildTeamPicker("anchorTeamUI", {
      maxPlayers: 3,
      disallowSetProvider: () => new Set(),
      onChange: (names) => { anchorTeam = names; save(); }
    });
    anchorPicker.setTeam(anchorTeam || []);

    // pool list with OUT toggles
    const pool = $("wheelPoolUI");
    pool.innerHTML = "";

    if(!playerNames.length){
      pool.innerHTML = `<div class="mini">Upload a Squabbit CSV to enable wheel mode.</div>`;
      return;
    }

    playerNames.forEach(n => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.justifyContent = "space-between";
      row.style.gap = "10px";
      row.style.padding = "8px 0";
      row.style.borderBottom = "1px solid rgba(255,255,255,.08)";

      const left = document.createElement("div");
      left.style.fontWeight = "950";
      left.textContent = n;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn " + (wheelOut.has(n) ? "btnBad" : "btnGhost");
      btn.style.padding = "8px 10px";
      btn.style.fontSize = "13px";
      btn.textContent = wheelOut.has(n) ? "OUT" : "IN";

      btn.onclick = () => {
        if(wheelOut.has(n)) wheelOut.delete(n); else wheelOut.add(n);
        save();
        buildWheelUI();
      };

      row.appendChild(left);
      row.appendChild(btn);
      pool.appendChild(row);
    });
  }

  function runWheel(){
    if(players.length === 0){
      alert("Upload a Squabbit CSV first.");
      return;
    }
    if(anchorTeam.length < 1){
      alert("Pick an anchor team first.");
      return;
    }
    if(anchorTeam.some(n => wheelOut.has(n))){
      alert("Your anchor team includes a player marked OUT. Set them to IN or change the anchor team.");
      return;
    }
    // remaining included players (excluding anchor team)
    const pool = playerNames.filter(n => !wheelOut.has(n) && !anchorTeam.includes(n));
    if(pool.length < 2){
      alert("Need at least 2 remaining included players to create 2-man combos.");
      return;
    }

    // build all 2-man combos
    const combos = [];
    for(let i=0; i<pool.length; i++){
      for(let j=i+1; j<pool.length; j++){
        combos.push([pool[i], pool[j]]);
      }
    }

    const ok = confirm(`Generate ${combos.length} wheel matchups?\n\nAnchor: ${anchorTeam.join(", ")}\nOpponents: every 2-man combo from ${pool.length} players.`);
    if(!ok) return;

    combos.forEach(c => {
      rows.push({ id: uid(), teamA: [...anchorTeam], teamB: [...c] });
    });

    lastRow = { teamA: [...anchorTeam], teamB: [...(combos[combos.length-1] || [])] };
    save();
    renderAll();
    window.scrollTo({ top: document.body.scrollHeight, behavior: "smooth" });
  }

  // ====== MAIN RENDER ======
  function setStatusTag(){
    if(players.length){
      $("statusTag").textContent = `Loaded: ${players.length} players`;
    } else {
      $("statusTag").textContent = "No round loaded";
    }
  }

  function renderAll(){
    setStatusTag();
    buildWheelUI();
    renderRows();
    updateFindPlayer();
  }

  // ====== EVENTS ======
  $("csvInput").addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const txt = await f.text();
    const parsed = parsePlayersFromCSV(txt);
    if(!parsed.length){
      alert("Could not find player scores in that CSV. Make sure it includes Hole 1–18 tables from Squabbit.");
      return;
    }
    players = parsed;
    playerNames = players.map(p => p.name).sort((a,b)=>a.localeCompare(b));

    // reset wheel toggles if they no longer match
    const all = new Set(playerNames);
    wheelOut = new Set([...wheelOut].filter(n => all.has(n)));
    anchorTeam = (anchorTeam || []).filter(n => all.has(n));

    save();
    renderAll();
  });

  $("addRowBtn").onclick = () => { editingRowId = null; openEntry(true); };
  $("copyLastBtn").onclick = () => { copyLast(); };
  $("runWheelBtn").onclick = () => { runWheel(); };

  $("perStroke").addEventListener("input", () => { save(); renderAll(); });
  $("maxPerPerson").addEventListener("input", () => { save(); renderAll(); });
  $("holesCounted").addEventListener("change", () => { save(); renderAll(); });

  $("findPlayer").addEventListener("input", () => { updateFindPlayer(); });

  // ====== HUB BAR (bottom) ======
  (function(){
    const TOOL_NAME = window.TOOL_NAME || document.title || "Golf Tool";
    const TOOL_KEYS = Array.isArray(window.TOOL_STORAGE_KEYS) ? window.TOOL_STORAGE_KEYS : [];
    const HUB_INDEX = window.HUB_INDEX || "index.html";

    $("hubToolTitle").textContent = TOOL_NAME;

    $("hubBackBtn").onclick = () => {
      // direct nav is most reliable on iOS
      window.location.href = HUB_INDEX;
    };

    $("hubResetThisBtn").onclick = () => {
      if(!TOOL_KEYS.length){
        alert("No reset keys set for this tool yet.");
        return;
      }
      const ok = confirm(`Reset this tool?\n\nThis clears:\n- ${TOOL_KEYS.join("\n- ")}`);
      if(!ok) return;
      TOOL_KEYS.forEach(k => localStorage.removeItem(k));
      alert("Tool reset. Reloading…");
      window.location.reload();
    };

    $("hubResetAllBtn").onclick = () => {
      const ok = confirm("Reset EVERYTHING for this site on this device?\n\nThis clears all local saved data.");
      if(!ok) return;
      localStorage.clear();
      alert("Everything reset. Returning to hub…");
      window.location.href = HUB_INDEX;
    };
  })();

  // ====== INIT ======
  const saved = loadSaved();
  if(saved){
    restore(saved);
  }
  setStatusTag();
  buildWheelUI();
  renderRows();
  updateFindPlayer();

})();
</script>
</body>
</html>